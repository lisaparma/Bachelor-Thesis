% Tutto quello riguardante il progetto andrà in questo capitolo 

\chapter{Tecnologie utilizzate}\label{chap:tec}
\section{Ambiente di sviluppo}
\subsection{Docker}
	\begin{figure}[H] 
		\centering
		\includegraphics[scale=0.3]{loghi/docker}
		\caption{Logo Docker}
	\end{figure}
Docker è una piattaforma per lo sviluppo, rilascio ed esecuzione di applicazione 
all'interno di \emph{container}. Questi ultimi forniscono una virtualizzazione a livello 
del sistema operativo \emph{Linux} senza che sia necessario istanziare delle macchine 
virtuali pienamente operative.
I \emph{container} sono assimilabili a delle macchine virtuali modulari con la peculiarità 
di essere molto leggere: in questo modo risulta più facile creare, distribuire, 
copiare e spostare i container da un ambiente all'altro.
Ogni \emph{container} è un processo isolato dagli altri \emph{container} e dal sistema ospite stesso: ogni volta che viene istanziato un nuovo \emph{container} si avrà un ambiente pulito, ovvero indipendente dal sistema ospite, da \emph{container} precedentemente creati e con le caratteristiche specificate. \\
Per sviluppare l'applicazione \emph{Teamwork} è stato utilizzato \emph{Docker 18.03 Community Edition} per \emph{Ubuntu Bionic}. In questo modo è stato possibile avviare nelle macchine locali un \emph{container} di \emph{Zimbra} e del \emph{core Zextras} con la \emph{zimlet OpenChat} caricata così da sviluppare l'applicativo in un ambiente controllato.

\subsection{IntelliJ IDEA} \label{subsec:IntelliJ}
	\begin{figure}[H] 
		\centering
		\includegraphics[scale=0.2]{loghi/intellij-idea}
		\caption{Logo IntelliJ IDEA}
	\end{figure}
IntelliJ IDEA è un \emph{\textbf{I}ntegrated \textbf{D}evelopment \textbf{E}nvironment} (\acrshort{IDE}) multi-linguaggio e multi-piattaforma. 
È stata utilizzata l'edizione \emph{Ultimate} in quanto era necessario un editor che 
supportasse JavaScript/TypeScript, mentre la \emph{Community Edition} non supporta questi linguaggi. 
Dovendo creare un'applicazione con numerose riferimenti al codice della \emph{zimlet 
OpenChat} e di \emph{Zimbra} sono state sfruttate al meglio le funzionalità per 
l'analisi del codice e comprendere le dipendenze esistenti. \\
Questo IDE non è stato imposto dall'azienda, ma è stato scelto personalmente per lo sviluppo dell'applicazione, in quanto avevo già dimestichezza con esso ed è stato consigliato dai dipendenti che sviluppano con JavaScript.

\subsection{Expo} \label{subsec:expo}
	\begin{figure}[H] 
		\centering
		\includegraphics[scale=0.05]{loghi/expo}
		\caption{Logo Expo}
	\end{figure}
Expo è una \emph{toolchain} \emph{open source} che permette la gestione di un progetto React Native utilizzando il \emph{\textbf{S}oftware \textbf{D}evelopment \textbf{K}it} (\acrshort{SDK}) di Expo. L'SDK Expo è una libreria nativa e JavaScript 
che fornisce l'accesso alle funzionalità del sistema del dispositivo (come la 
fotocamera, i contatti, la memoria locale) senza il bisogno di utilizzare \gl{xCode}{xCode} 
o \gl{Android Studio}{Android Studio}, né di utilizzare codice nativo. Fornisce l'accesso a servizi 
che in genere sono difficili da gestire nativamente, ma sono richiesti da quasi 
tutte le app come le notifiche \emph{push} o creare binari nativi pronti per la 
distribuzione nell'\emph{app store}.
Inoltre semplifica e velocizza le fasi di sviluppo e di testing in quanto
permette l'avvio di \emph{build} automatiche nei loro \emph{server} che
permettono di eseguire in \emph{real-time} il codice sia in simulatori che in
dispositivi mobili.
L'utilizzo di questo tool è stato un requisito obbligatorio del progetto. La validazione di Expo è infatti uno degli scopi dello stage, in quanto l'azienda vorrebbe implementarla nei suoi progetti futuri.


\section{Linguaggi, librerie e strumenti di programmazione}

\subsection{React Native}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.1]{loghi/React}
	\caption{Logo React Native}
\end{figure}
React Native è un \emph{framework} per lo sviluppo di applicazioni mobile in JavaScript 
che permette di unificare l'esperienza di sviluppo su diversi sistemi operativi. 
Infatti React Native utilizza le stesse componenti dell'interfaccia 
utente che vengono utilizzate da app native iOS e Android.
Si possono comunque integrare dei componenti scritti in \emph{Objective-C}, 
\emph{Java} o \emph{Swift} così da utilizzare il codice nativo nel caso fosse
necessario 
ottimizzare alcuni aspetti dell'applicazione in base alla piattaforma. 
React Native si basa su ReactJS dove risulta fondamentale il concetto di 
"componente''. Un componente è un modulo dell'applicazione che ha uno stato, 
che può accettare delle proprietà e che ha un proprio ciclo di vita. 
Questo approccio di sviluppo atomico risulta perfetto per effettuare Unit Test 
o per creare componenti più complessi includendone di più semplici.


\subsection{TypeScript} \label{subsec:tslint}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.07]{loghi/ts}
	\caption{Logo TypeScript}
\end{figure}
TypeScript è un linguaggio di programmazione sviluppato da \emph{Microsoft} che 
estende la sintassi di JavaScript.  È nato per poter utilizzare le funzionalità di 
JavaScript per lo sviluppo di grandi applicazioni in quanto aumenta la 
sicurezza e la robustezza del codice tramite l'aggiunta di classi, interfacce, 
moduli, tipizzazione e altre funzionalità importanti per la comprensione di un 
grande progetto. 
Il codice TypeScript sviluppato viene successivamente ricompilato in JavaScript 
per poter essere interpretato da browser o app.\\
L'utilizzo di questo linguaggio invece che JavaScript non è stato imposto dall'azienda, ma caldamente suggerito dal tutor aziendale. Ho voluto utilizzarlo per imparare un nuovo linguaggio che può portare grandi benefici soprattutto, in termini di chiarezza.

\subsection{TSLint}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.4]{loghi/TSlint}
	\caption{Logo TS Lint}
\end{figure}
TSLint è uno strumento di \gl{analisi statica}{analisi statica} per il codice scritto in TypeScript 
che offre funzionalità estendibili e personalizzabili per la leggibilità, la 
manutenibilità e gli errori di programmazione. 
È supportato da molti dei moderni editor, compreso \emph{IntelliJ IDEA} (sez. 
\ref{subsec:IntelliJ}), utilizzato per il progetto. \\
In parallelo con TypeScript, l'utilizzo di TSLint non è stato obbligatorio ma
data la scelta di utilizzare un nuovo linguaggio ho preferito utilizzare questo linter, per essere più precisa nella grammatica del codice.

\subsection{Redux} \label{subsec:Redux}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.06]{loghi/redux}
	\caption{Logo Redux}
\end{figure}
Redux è una libreria JavaScript per la gestione semplificata dello stato delle 
applicazioni web. In ReactJS e React Native ogni componente possiede uno stato 
che può cambiare durante il suo ciclo di vita. Questo stato è interno ad ogni 
singola componente ed è difficile, a volte impossibile, la comunicazione di questi 
dati tra componenti diverse. 
Redux, invece, permette la creazione di uno \emph{store} condiviso, accessibile da tutte 
le componenti. In tal modo è possibile sincronizzare le modifiche e quindi 
avere dei dati coerenti tra le varie componenti. 
Nella zimlet OpenChat era già stata utilizzata questa tecnologia e volendo sia
sincronizzare i dati, sia mantenere la struttura il più simile possibile, si è voluto continuare ad usare questa soluzione, anche perché è l'unico modo per gestire in maniera semplice un numero di dati ampio e in continuo cambiamento.
Redux è stato implementato basandosi su una particolare architettura: 
\hyperref[subsec:flux]{Flux}.

\subsubsection{Flux} \label{subsubsec:flux}
 Flux è un \gl{pattern architetturale}{pattern architetturale} che ha ispirato Redux, utilizzato per la 
 creazione di applicazioni web \emph{client-side}. Esso utilizza un flusso di dati 
 unidirezionale per gestire al meglio la sincronizzazione degli stati tra le 
 componenti React, in modo da garantire che lo stato dello \emph{store} sia 
 sempre uguale in tutte le componenti che compongono la \emph{view}.
 
 \begin{figure}[H] 
 	\centering
 	\includegraphics[scale=0.3]{loghi/flux}
 	\caption{Flusso dei dati in Flux}
 \end{figure}
Il flusso parte da degli oggetti \emph{stores}, i quali contengono i dati dell'applicazione che vengono forniti ai vari componenti in modo che la view sia sempre aggiornata con questi dati. \\
Per modificare i dati presenti in uno store è necessario creare un oggetto \emph{action} che, mediante il \emph{dispatcher} dell’applicazione, viene ricevuto dai vari \emph{stores}, i quali lo utilizzano per aggiornare i dati che contengono.

 
\section{Strumenti di verifica e valutazione}

\subsection{Genymotion} \label{subsez:genymotion}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.3]{loghi/genymotion2}
	\caption{Logo Genymotion}
\end{figure}
Genymotion è un emulatore software di dispositivi Android. Si integra 
perfettamente con Expo(sez. \ref{subsec:expo}) ed è utilizzato per la gestione
di questo progetto, permettendo di avere un riscontro dell'app in \emph{real-time} durante 
lo sviluppo e di verificare e testare l'applicazione su più \emph{device}. Emula più 
di 3000 configurazioni virtuali di dispositivi Android (tra versioni, dimensioni 
schermo, capacità hardware, ecc..). 

\subsection{React Native Debugger}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.15]{loghi/react-native-debugger}
	\caption{Logo React Native Debugger}
\end{figure}
React Native Debugger è un applicazione \emph{standalone} per il \emph{debug} di app in React 
Native. Si basa sul \emph{remote debugger} disponibile quando si monitora un
progetto in un \emph{device} fisico o virtuale.
Esso offre vari strumenti per il \emph{debug}:
\begin{itemize}
	\item \textbf{React Inspecto}r, per ispezionare il \emph{layout} e lo \emph{style} di ogni componente dell'app;
	\item \textbf{Redux DevTools}, per monitorare gli \emph{store} Redux utilizzati e le \emph{action} svolte su di essi;
	\item \textbf{Console}, per visualizzare errori e avvisi che avvengono durante l'esecuzione del codice.
\end{itemize}
Purtroppo la scelta di utilizzare questo debugger è dettata dal fatto che, al momento, è l'unica soluzione che include tutte le funzionalità utilizzate di React Native.

\subsection{Jest} \label{subsez:jest}
\begin{figure}[H] 
	\centering
	\includegraphics[scale=0.13]{loghi/jest}
	\caption{Logo Jest}
\end{figure}
Jest è un \emph{framework }di \gl{unit testing}{unit testing} per JavaScript
sviluppato ed utilizzato da \emph{Facebook} per testare le proprie applicazioni
in React. È una soluzione completa e pronta all'utilizzo, in quanto è
automaticamente configurata alla creazione di un nuovo progetto React Native.
Rispetto ad altri \emph{framework} di unit testing offre dei vantaggi, come: 
\begin{itemize}
	\item vengono eseguiti solo i file di test relativi ai file modificati;
	\item gestisce automaticamente le dipendenze durante l'esecuzione dei test;
	\item permette di testare in modo sincroni il codice asincrono;
	\item esegue i test in processi paralleli così che finiscano prima.
\end{itemize}
Inoltre Jest funziona con qualsiasi linguaggio \emph{compile-to-JavaScript}. 
Sia il codice da testare che i test stessi possono essere scritti in TypeScript, 
linguaggio utilizzato per questo progetto. 
