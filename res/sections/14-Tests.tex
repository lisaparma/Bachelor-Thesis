% VERIFICA E VALIDAZIONE

\chapter{Verifica e Validazione}\label{chap:tests}
\section{Linter}
Come strumento di verifica statica del codice è stato utilizzato TSLint, descritto nella sezione \ref{subsec:tslint} di questo elaborato. Questo linter specifico per codice TypeScript segnala errori di programmazione, errori stilistici e costrutti sospetti in base a determinati criteri personalizzabili durante la codifica dei programmi.\\
In particolare è stato utilizzato per rendere conforme il codice scritto alle convenzioni utilizzate in azienda. Degli esempi sono:
\begin{itemize}
	\item dichiarazione dei tipi e delle interfacce obbligatoria;
	\item utilizzo di particolari costrutti, come l'utilizzo di cicli 'for-of' al posto di cicli 'for' standard se l'indice è usato solo per accedere all'array che viene iterato;
	\item ordine alfabetico per importazioni e attributi; 
	\item obbliga la dichiarazione dello scope di variabili e funzioni, impedendo l'importazione di variabili, funzioni e membri privati.
\end{itemize}
\section{Jest}
I test automatici sviluppati sono stati eseguiti in numero ridotto ripetto a quelli utili ad analizzare in modo completo il comportamento dell'applicazione in quanto si è preferito, per volontà dell'azienda, investire più tempo nello sviluppo di funzionalità che nel loro test approfondito data la ridotta durata dello stage. \\
Per rendere completa l'esperienza di stage e riuscire a toccare tutto il ciclo di vita dello sviluppo del progetto sono comunque stati fatti dei test automatici. Per fare ciò è stato utilizzato Jest.js (sez. \ref{subsez:jest}), tool di testing specifico per i progetti ReactJS e React Native integrato nella configurazione del progetto. \\
Sono stati sviluppati due tipologie di test:
\begin{itemize}
	\item Snapshot test per le componenti;
	\item Snapshot test action e reducer Redux.
\end{itemize}
Vediamoli in dettaglio.
\subsection{Component snapshot}
Ogni componente React Native possiede uno stato e delle props che possono variare durante il suo ciclo di vita, facendo variare anche il suo rendering. Attraverso questa tipologia di test si controllano questi cambiamenti creando degli snapshot di come il componente dovrebbe essere renderizzato. \\
In questo modo quando andremo a modificare il codice avremo la sicurezza di non dover controllare il rendering facendo una valutazione grafica su emulatori o device perchè i test ci informeranno su eventuali cambiamenti inaspettati. La cosa migliore è effettuare dei test con dei mock dei vari stati possibili, in modo da avere la certezza di coprire tutti i possibili casi di rendering.

\subsection{Redux snapshot}
Questi test servono a verificare se le funzionalità introdotte con action e reducers producono effettivamente il risultato voluto sullo store Redux. 
Passando un'action ed uno stato ad un reducers questo dovrebbe ritornarci un nuovo stato. Una volta implementato è facile definire il comportamento desiderato tramite uno snapshot ed applicare questo al nostro test così che venga simulato per ogni stato trovato nell'applicaz .............
Le action risultano come semplici funzioni che ritornano un oggetto e per testarle si simula...........
\section{Test di sistema e collaudo}
Per accertare la copertura dei requisiti si è ricorso a delle prove pratiche del corretto funzionamento dell’applicazione. Questa operazione è stata svolta sia come strumento per la verifica delle operazioni durante lo sviluppo del prodotto software che come operazione di collaudo per assicurare il corretto funzionamento del prodotto una volta implementate tutte le funzioni richieste. \\
Grazie al framework per lo sviluppo utilizzato, Expo, è stato facile testare fin dalle prime implementazioni di funzionalità il prodotto dato che permete build automatiche in realtime testabili attraverso link su vari device contemporaneamente.
\subsection{Emulatori}
È stato molto utile accompagnare la parte finale dello sviluppo del codice ad un continuo rendering dell'applicazione. Attraverso gli emulatori collegati al framework di sviluppo è stato possibile testare ogni modifica del codice quasi simultaneamente al salvataggio delle modifiche, rendendo più agile l'implementazione della grafica. \\
Per aver il più ampio spettro possibile di device simulati sono stati utilizzati due diversi simulatori: Genymotion (sez. \ref{subsez:genymotion}) per i dispositivi Android e iOS Simulator per iOS.
I device emulati su cui è stata testata ogni funzione dell'applicazione sono:
\begin{itemize}
	\item Google Nexus 6;
	\item Google Pixel;
	\item Google Pixel XL;
	\item HTC One;
	\item Samsung Galaxy Note;
	\item Samsung Galaxy S3;
	\item Samsung Galaxy S6;
	\item Samsung Galaxy S8;
	\item Sony Xperia Z;
	\item iPhone 5s;
	\item iPhone 6 plus;
	\item iPhone 7;
	\item iPhone X.
\end{itemize}
Sui device appena elencati sono stati utilizzati i seguenti sistemi operativi per accedere all'applicazione:
\begin{itemize}
	\item Android 5.1.0, API level 22 or Lollipop;
	\item Android 6.0.0, API level 23 or Marshmallow;
	\item Android 7.1.0,  API level 24 or Nougat;
	\item Android 8.0.0,  API level 26 or Oreo;
	\item iOS9 (9.3.5);
	\item iOS10 (10.3.3);
	\item iOS11 (11.4.1).
\end{itemize}
\subsection{Device fisici}
Oltre agli emulatori sono stati utilizzati dei device fisici dell'azienda a disposizione degli sviluppatori per installare e testare l'applicazione. Per fare ciò è stato richiesto di costruire dei file binari dell'applicazione Expo per iOS (.ipa) ed Android (.apk). \\
I device su cui è stata testata Teamwork:
\begin{itemize}
	\item HTC Desire 825;
	\item Samsung Z3;
	\item Samsung Galaxy J3;
	\item Tablet Fire 7;
	\item iPhone 5;
	\item iPhone X;
	\item iPad 2;
\end{itemize}

\subsection{Beta testing}
Le funzionalità apportate all'applicazione durante il periodo di stage sono state più accurate e numerose di quelle inizialmente stabilite, tanto che si è deciso di procedere ad una fase di beta testing interno all'azienda.\\
\subsubsection{Test Flight}
Attraverso il programma per sviluppatori Apple si è avviata la procedura per poter caricare le build (.ipa) dell'applicazione sull' App Store Connect, così da permettere il testing attraverso TestFlight.\\
TestFlight è un'applicazione utilizzata per testare applicazioni non ancora sullo store ufficiale, usufruibile da chiunque sia stato invitato a provare la beta. Tramite questo programma si ha la possibilità di far testare l'applicazione ad un massimo di 25 persone interne. 
Tramite il loro utilizzo dell'applicazione gli sviluppatori riceveranno dati concernenti lo stato dell'applicazione in funzione, gli errori e i warning sviluppatosi così da avere un'overview generale sull'andamento dell'applicazione su altri device. Inoltre i tester possono inviare segnalazione e suggerimenti. \\
Dopo questa prima fase di testing interno è obbligatorio procedere ad un testing esterno prima di pubblicare l'applicazione sull'Apple Store.